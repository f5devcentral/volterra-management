import requests
import json
import datetime
import logging
import time
from urllib3.util.retry import Retry


def createVoltSession(token: str, tenantName: str) -> dict:
    now = datetime.datetime.now()
    apiToken = "APIToken {0}".format(token)
    s = requests.Session()
    s.headers.update({'Authorization': apiToken})
    urlBase = "https://{0}.console.ves.volterra.io".format(tenantName)
    create = {
        'operation': 'createVoltSession',
        'status': 'success',
        'message': 'voltSession created',
        'time': now.strftime("%m/%d/%Y, %H:%M:%S")
    }
    session = {'session': s, 'urlBase': urlBase, 'lastOp': create}
    createCache(session)
    return session


def updateSO(s: dict, op: str, status: str, message: str) -> dict:
    now = datetime.datetime.now()
    action = {
        'operation': op,
        'status': status,
        'time': now.strftime("%m/%d/%Y, %H:%M:%S"),
        'message': message
    }
    s['lastOp'] = action
    return s

def updateToken(s: dict, tokenName: str, expiryDays: int=7) -> dict:
    url = s['urlBase'] + "/api/web/namespaces/system/renew/api_credentials"
    tokenPayload = {
        "name": tokenName,
        "expiration_days": expiryDays,
    }
    try:
        resp = s['session'].post(url, json=tokenPayload)
        resp.raise_for_status()
        return updateSO(s, 'updateToken', 'success', 'token updated')
    except requests.exceptions.RequestException as e:
        return updateSO(s, 'updateToken', 'error', e)

def createCache(s: dict, cacheTO: int=60) -> dict:
    urlUsers = s['urlBase'] + "/api/web/custom/namespaces/system/user_roles"
    try:
        resp = s['session'].get(urlUsers)
        resp.raise_for_status()
        users = json.loads(resp.text)['items']
    except requests.exceptions.RequestException as e:
        return updateSO(s, 'createCache', 'error', e)
    except json.decoder.JSONDecodeError as e:
        return updateSO(s, 'createCache', 'error', e)
    urlNSs = s['urlBase'] + "/api/web/namespaces"
    try:
        resp = s['session'].get(urlNSs)
        resp.raise_for_status()
        namespaces = json.loads(resp.text)['items']
    except requests.exceptions.RequestException as e:
        return updateSO(s, 'createCache', 'error', e)
    except json.decoder.JSONDecodeError as e:
        return updateSO(s, 'createCache', 'error', e)
    expiry = datetime.datetime.now() + datetime.timedelta(seconds=cacheTO)
    cache = {
        'expiry': expiry.timestamp(),
        'users': users,
        'namespaces': namespaces,
    }
    s['cache'] = cache
    updateSO(s, 'createCache', 'success', "Cache populated")


def findUserNS(email: str) -> str:
    userNS = ""
    if "#EXT#@" in email:
        userNS = email.split(
            '#EXT#@')[0].replace('.', '-').replace('_', '-').lower()
    else:
        userNS = email.split('@')[0].replace('.', '-').lower()
    return userNS

def removeUserRoles(s: dict) -> dict:
    if s['cache']['expiry'] < datetime.datetime.now().timestamp():
        createCache(s)
    def_roles = [
        {'namespace': 'default', 'role': 'ves-io-default-role'},
        {'namespace': 'shared', 'role': 'ves-io-default-role'},
        {'namespace': 'system', 'role': 'ves-io-default-role'}
    ]
    removeUsers = [user for user in s['cache']['users'] if ((user['namespace_roles'] == def_roles) and (user['domain_owner'] == False))]
    if len(removeUsers) > 0:
        for user in removeUsers:
            delUser(user['email'], s)
    updateSO(s, 'removeUserRoles', 'success', '{0} Users removed'.format(len(removeUsers)))


def checkUserNS(email: str, s: dict) -> dict:
    if s['cache']['expiry'] < datetime.datetime.now().timestamp():
        createCache(s)
    userNS = findUserNS(email)
    thisUserNS = next(
        (ns for ns in s['cache']['namespaces'] if ns['name'] == userNS), None)
    if thisUserNS:
        return updateSO(s, 'checkUserNS', 'present', 'UserNS {0} is present'.format(userNS))
    return updateSO(s, 'checkUserNS', 'absent', 'UserNS {0} is absent'.format(userNS))


def checkUser(email: str, s: dict) -> dict:
    if s['cache']['expiry'] < datetime.datetime.now().timestamp():
        createCache(s)
    thisUser = next(
        (user for user in s['cache']['users'] if user['email'].lower() == email.lower()), None)
    if thisUser:
        return updateSO(s, 'checkUser', 'present', 'User {0} is present'.format(email))
    return updateSO(s, 'checkUser', 'absent', 'User {0} is absent'.format(email))


def createUserNS(email: str, s: dict) -> dict:
    userNS = findUserNS(email)
    url = s['urlBase'] + "/api/web/namespaces"
    nsPayload = {
        'metadata':
            {
                'annotations': {},
                'description': 'automatically generated by tenant admin',
                'disable': False,
                'labels': {},
                'name': userNS,
                'namespace': ''
            },
        'spec': {}
    }
    try:
        resp = s['session'].post(url, json=nsPayload)
        resp.raise_for_status()
        return updateSO(s, 'createUserNS', 'success', 'NS {0} was created'.format(email))
    except requests.exceptions.RequestException as e:
        return updateSO(s, 'createUserNS', 'error', e)


def delUserNS(email: str, s: dict) -> dict:
    userNS = findUserNS(email)
    url = s['urlBase'] + \
        "/api/web/namespaces/{0}/cascade_delete".format(userNS)
    nsPayload = {
        "name": userNS
    }
    try:
        resp = s['session'].post(url, json=nsPayload)
        resp.raise_for_status()
        return updateSO(s, 'delUserNS', 'success', 'NS {0} deleted'.format(email))
    except requests.exceptions.RequestException as e:
        return updateSO(s, 'delUserNS', 'error', e)


def createUserRoles(email: str, first_name: str, last_name: str, s: dict, createdNS: str=None, exists: bool=False, admin: bool=False) -> dict:
    url = s['urlBase'] + "/api/web/custom/namespaces/system/user_roles"
    if admin:
        namespace_roles = [
            {'namespace': 'system', 'role': 'ves-io-admin-role'},
            {'namespace': '*', 'role': 'ves-io-admin-role'},
            {'namespace': 'default', 'role': 'ves-io-admin-role'},
            {'namespace': 'shared', 'role': 'ves-io-admin-role'}
        ]
    else:
        namespace_roles = [
            {'namespace': 'system', 'role': 'ves-io-power-developer-role'},
            {'namespace': 'system', 'role': 'f5-demo-infra-write'},
            {'namespace': '*', 'role': 'ves-io-monitor-role'},
            {'namespace': 'default', 'role': 'ves-io-power-developer-role'},
            {'namespace': 'shared', 'role': 'ves-io-power-developer-role'}
        ]
    userPayload = {
        'email': email.lower(),
        'first_name': first_name,
        'last_name': last_name,
        'name': email.lower(),
        'idm_type': 'SSO',
        'namespace': 'system',
        'namespace_roles': namespace_roles,
        'type': 'USER'
    }
    if createdNS:
        userPayload['namespace_roles'].append(
            {'namespace': createdNS, 'role': 'ves-io-admin-role'})
    try:
        if exists:
            resp = s['session'].put(url, json=userPayload)
        else:
            resp = s['session'].post(url, json=userPayload)
        resp.raise_for_status()
        return updateSO(s, 'createUserRoles', 'success', 'User {0} and Roles created/updated'.format(email))
    except requests.exceptions.RequestException as e:
        return updateSO(s, 'createUserRoles', 'error', e)

def delUser(email: str, s: dict) -> dict:
    url = s['urlBase'] + "/api/web/custom/namespaces/system/users/cascade_delete"
    userPayload = {
        "email": email.lower(),
        "namespace": "system"
    }
    try:
        resp = s['session'].post(url, json=userPayload)
        resp.raise_for_status()
        return updateSO(s, 'delUser', 'success', 'User {0} deleted'.format(email))
    except requests.exceptions.RequestException as e:
        return updateSO(s, 'delUser', 'error', e)

def addUser(s: dict, email: str, first_name: str, last_name: str) -> dict:
    checkUser(email, s)
    if s['lastOp']['status'] == 'present':
        return updateSO(s, 'addUser', 'error', 'User {0} already exists.'.format(email))
    checkUserNS(email, s)
    if s['lastOp']['status'] == 'present':
        return updateSO(s, 'addUser', 'error', 'NS {0} already exists.'.format(findUserNS(email)))
    createUserNS(email, s)
    createdNS = findUserNS(email)
    createUserRoles(email, first_name, last_name, s, createdNS, False, False)
    if s['lastOp']['status'] == 'success':
        return updateSO(s, 'addUser', 'success', 'User {0} created.'.format(email))
    else:
        return updateSO(s, 'addUser', 'error', 'Failed to create user {0}: {1} '.format(email, s['lastOp']['message']))
